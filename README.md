# COMP6630_ML_Final_Project
Multilayer Perceptron (MLP) for binary image classification. MLP coded from scratch in partial fulfillment of COMP 6630 | Machine Learning, Auburn University. 
## Project Description:
World hunger is a growing issue in post-pandemic society.  According to the World Food Program, as many as 828 million people go to bed hungry every night. This has made a push to improve the technical resources available to farmers. The motivation for this project is to utilize a Multilayer Perceptron (MLP) to identify diseased tomato leaves, as an early detection method to prevent spread and improve crop yields. Results are promising at 79.4 percent accuracy on a k-fold cross validation test set. Methods for determining optimal hyperparamters are shown, and compared against a Convolutional Neural Network (CNN) in Resnet18 as well as a stock open source MLP from SKLearn.
## Data Loader
The data processing script is called generateCSV.py. The CSV File Generator is relatively straight forward in its functionality. In the first lines of the script you will find the paths reading in the filenames, this is denoted as root path. This is where the images are stored, and are in sub folders (Healthy and Diseased). The following lines dictate the directory and filename for the csv files to be written. There is a csv file for the healthy images, and a csv file for the diseased images. The remainder of the script is responsible for doing the actual reading and writing. There are loops for both the healthy and diseased csv. The logic is basically to read in each filename from the specified directory and write it to the csv file. Additonally the second coloumn of the csv holds the label. Either a 0 (Healthy) or a 1 (Diseased).
To modify the script for a new use, all that would be required is to first change the directories to what they are referred to on your machine. This includes changing where the images are read from, and where the CSVs are written to. Additionally for each of the loops, the in paths will need to be modified to contain the correct folder name dictating which folder to read from. Also the labels (0 or 1) might need to be changed to fit the specific application. 
## Image Preprocessor
The preprocessing module utilizes OpenCV to perform image processing tasks. This includes resizing the image so that it is a specified size. It also includes the 3 options used in the report analysis. All of this functionality is available by 
using the fix_image function in the module folder. It is already included in the scripts that called it. It takes inputs of the image name, the image width, the image height, and the argument for which image process you want performed. This can be 1 for RGB, 2 for grayscale, 3 for canny edge detection (not used in report), and 4 for sobel edge detection. The function returns the image. The other function in the preprocessing module is the get\_array function. As the name implies, the function returns the input image as a 1D array. 
## MLP
Our MLP is found in the script KFold_ours.py. Once the data is downloaded and pre processed into .csv files in folders, replace the path to the data folders into the script. 
For using our MLP, The MLP is developed as a class in python. When a instance of the class is instantiated, the MLP must be given an integer for the number of elements in the input array, and integer for the number of hidden layers, an array of integers for the number of nodes in each of the hidden layers, and a float for the learning rate. The number of nodes array must have at least two elements even if there is only one hidden layer in order for the indexing to work appropriately. If there is only one hidden layer, zero pad the number of nodes array after the first entry. 

Once the class is initialized, the function train_nn can be used to train your weighting matrices in the class. The function takes in a single input vector and label pair. The function will then forward propagate the input, calculate the error at the output, back propagate to calculate the error at every node, and then update all of the weighting matrices with the connected errors and inputs. For training, nested loops must be used to iterate the training function across the full training dataset, with the outer loop iterating over the full training set for the full number of desired epochs. Once the training is finished, the trained weights will be kept in the class instance.

After training, the MLP can be used to predict the output of an image with the function predict_nn. The function takes in only the input vector. It then forward propagates the input and returns the prediction value. Again, a loop is required to iterate and predict the output for the full data set. Once the predictions are generated, then accuracy, precision, and recall can be calculated.

There is also a function called getLoss that takes in a label and returns the loss for the current trained network, label, and last run input vector.

## Benchmarks
There are two benchmark scripts included as well, KFold_SKlearn.py and PytorchCNN_KFold.py. Both scripts will have to have the data paths renamed to reflect where you keep the data. For more documentation on there functionality, google SciKit and Pytorch. 

